""" module that can generate c-style eBPF programs given a list of probes to attach to and their arguments """
import pdb
from util import STRING_TYPE, PROBE_NAME_KEY, PROBE_ARGS_KEY, ARG_TYPE_KEY

class Probe:
    def __init__(self, probe_dict):
        if not isinstance(probe_dict, dict):
            raise TypeError("Probe must be a dict!")

        self.name = probe_dict[PROBE_NAME_KEY]
        self.hits = probe_dict["hits"]
        self.args = [Arg(arg, self.hits, self.name, index) for index, arg in enumerate(probe_dict[PROBE_ARGS_KEY])]

class Arg:
    def __init__(self, arg_dict, num_hits, probe_name, index, depth = 0):
        if not isinstance(arg_dict, dict):
            raise TypeError("arg_dict must be a dict!")
        self.type = arg_dict[ARG_TYPE_KEY]
        self.probe_name = probe_name
        self.depth = depth
        self.index = index
        self.output_arg_name = 'arg_{}_{}'.format(self.depth, self.index)
        if self.type == STRING_TYPE:
            self.length = arg_dict["length"]

        if self.type == 'struct':
            self.values = [Arg(val, num_hits, probe_name, child_index, depth = depth + 1) for child_index, val in enumerate(arg_dict["values"])]

    def __str__(self):
        return self.type + ' ' + self.output_arg_name

    def get_c_name(self):
        if self.type == STRING_TYPE:
            return 'char {arg_name}[{length}]'.format(arg_name = self.output_arg_name, length = self.length)
        elif self.type == 'struct':
            return 'struct {probe_name}_level_{depth}_{index} {arg_name}'.format(probe_name = self.probe_name, depth = self.depth, arg_name = self.output_arg_name, index = self.index)
        else:
            return '{type_} {arg_name}'.format(type_ = self.type, arg_name = self.output_arg_name)

    def before_output_gen(self):
        if self.type != 'struct':
            return
        result = ''
        for member in self.values:
            if member.type == 'struct':
                result += member.before_output_gen()

        result += '\rstruct {probe_name}_level_{depth}_{index} {{\n'.format(probe_name = self.probe_name, depth = self.depth, index = self.index)
        for member in self.values:
            result += '\r\t' + member.get_c_name() + ';\n'
        result += '};\n'
        return result

    def get_output_struct_def(self):
        if self.type != 'struct':
            print(self.type)
            return '\r\t' + self.get_c_name() + ';\n'
        result = ''
        for arg in self.values:
            result += '\r\t' + arg.get_output_struct_def()
        return result

    def fill_output_struct(self, source_struct_name = None, base_addr_name = None):
        if self.type == STRING_TYPE and not source_struct_name:
            # have to extract from char* in USDT arg
            assert(self.depth == 0)
            return """
            \r\tconst char* addr_{depth}_{arg_index} = NULL;
            \r\tbpf_usdt_readarg({arg_num}, ctx, &addr_{depth}_{arg_index});
            \r\tbpf_probe_read_str(&{out_struct_name}.{out_member}, sizeof({out_struct_name}.{out_member}), addr_{depth}_{arg_index});
            """.format(depth = self.depth, arg_num = self.index + 1, arg_index = self.index, out_struct_name = 'out', out_member = self.output_arg_name)
        elif self.type == 'struct':
            if self.depth:
                result = ''
                source_struct_name += '.' + self.output_arg_name
            else:
                # Can't access C runtime (strcpy, etc) and there are no loops.
                # Thus, to copy strings from embedded structs to the output struct, the offset within the passed in struct
                # is determined, and then a bpf_probe_read_str is issued, reading the string from userspace once more
                # See https://github.com/iovisor/bcc/issues/691 for updates on string builtin functions
                assert(self.depth == 0)
                base_addr_name = 'addr_0_{index}'.format(index = self.index)
                result = """
                \r\tstruct {probe_name}_level_0_{index} base_struct = {{}};
                \r\tconst void* addr_0_{index} = NULL;
                \r\tbpf_usdt_readarg({arg_num}, ctx, &addr_0_{index});
                \r\tbpf_probe_read(&base_struct, sizeof(base_struct), addr_0_{index});
                """.format(probe_name = self.probe_name, index = self.index, arg_num = self.index + 1)
                source_struct_name = 'base_struct'
            for arg in self.values:
                result += arg.fill_output_struct(source_struct_name, base_addr_name) + '\n'
            return result
        elif source_struct_name:
            if self.type == STRING_TYPE:
                result = """
                \r\tvoid* str_loc_{index} = {source};
                \r\tu64 offset_{index} = str_loc_{index} - {base_addr_name};
                \r\tconst char* user_str_{index} = (const char*)({base_addr_name} + offset_{index});
                \r\tbpf_probe_read_str(out.{target}, sizeof(out.{target}), user_str_{index});
                """.format(source = source_struct_name + '.' + self.output_arg_name,
                        base_addr_name = base_addr_name,
                        target = self.output_arg_name,
                        index = self.index)
                return result
            return '\r\tout.{target} = {source};\n'.format(target = self.output_arg_name, source = source_struct_name + '.' + self.output_arg_name)
        else:
            return '\r\tbpf_usdt_readarg({}, ctx, &{});\n'.format(self.index + 1, 'out.' + self.output_arg_name)





class Generator:
    def __init__(self):
        self.c_prog = '#include <linux/ptrace.h>\n'
        # self.c_prog += """
        # \rstatic inline int custom_strcpy(char* dest, const char* str) {
        # \r    const int MAX_BYTES = 20; //max stack size
        # \r    #pragma unroll 20
        # \r    for(int i = 0; i < MAX_BYTES; ++i) {
        # \r        dest[i] = str[i];
        # \r        if(!dest[i]) break;
        # \r    }
        # \r    return 0;
        # \r}
        # """

    def finish(self):
        return self.c_prog

    def add_probe(self, probe):
        if not isinstance(probe, Probe):
            raise TypeError("Probe must be a dict!")
        for arg in probe.args:
            if arg.type == 'struct':
                self.c_prog += arg.before_output_gen()

        self.c_prog += "\n\nBPF_PERF_OUTPUT({});\n".format(probe.name)
        self.c_prog +="\nstruct {}_output {{\n".format(probe.name)
        for  arg in probe.args:
            self.c_prog += arg.get_output_struct_def()
        self.c_prog += '\r};\n\n'

        self.c_prog += '\rint {}_fn(struct pt_regs *ctx) {{\n'.format(probe.name)
        self.c_prog += '\r\tstruct {}_output out = {{}};\n'.format(probe.name)
        for arg in probe.args:
            self.c_prog += arg.fill_output_struct()
        self.c_prog += '\r\t{}.perf_submit(ctx, &out, sizeof(out));\n'.format(probe.name)
        self.c_prog += '\r\treturn 0;\n}\n'
