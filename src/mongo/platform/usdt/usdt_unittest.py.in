#!/usr/bin/env python3
import os
import subprocess
import sys
print("Running with", sys.executable)
import tempfile
import time

# verify bcc is installed
try:
    import bcc
except ImportError:
    print("BCC module not present, USDT tests cannot be run.")
    exit(0)

def failed_process(retStatus):
    return os.WIFSIGNALED(retStatus) or (os.WIFEXITED(retStatus) and os.WEXITSTATUS(retStatus))

def main():
    failed_exes = []
    try:
        try:
            # create temp directory
            tmp_dirname = "@usdt_tmp_dirname@"
            tmp_dirname = os.path.join(os.getcwd(), tmp_dirname)
            print("Temporary directory: {}".format(tmp_dirname))

            os.mkdir(tmp_dirname)
        except FileExistsError:
            print("File exists.")
        except OSError:
            print("Failed to create a temporary directory for named pipes.")
            exit(1)

        # create named pipes for subprocesses to communicate
        try:
            cpp_wr_fifo_name = os.path.join(tmp_dirname, "cpp_wr_fifo")
            os.mkfifo(cpp_wr_fifo_name)
        except OSError as ose:
            if (ose.errno != EEXIST):
                print("Failed to create named pipe.")
                exit(1)

        py_wr_fifo_name = os.path.join(tmp_dirname, "py_wr_fifo")
        os.mkfifo(py_wr_fifo_name)

        # set up python child
        rp = os.path.realpath(__file__)
        dn = os.path.dirname(rp)
        exec_py_name = os.path.join(dn, 'python_tester/@usdt_probe_test_py@')
        py_interpreter = '@usdt_probe_test_python_interpreter@'
        exec_py_name = "sudo {} {} {} {}".format(sys.executable, exec_py_name, py_wr_fifo_name, cpp_wr_fifo_name)

        # run tests
        test_list = '@usdt_probe_tests@'.split()
        for test in test_list:
            # launch python executable
            print("Running: {}".format(exec_py_name))
            exec_py_list = exec_py_name.split()
            py_pr = subprocess.Popen(args=exec_py_list, executable=exec_py_list[0], close_fds=False)

            # launch C++ executable
            exec_cpp_name = os.path.join(dn, test)
            print("Running: {}".format(exec_cpp_name))
            cpp_pr = subprocess.Popen(args=[exec_cpp_name, py_wr_fifo_name, cpp_wr_fifo_name], executable=exec_cpp_name, close_fds=False)

            (pid, retStatus) = os.wait()
            if failed_process(retStatus):
                failed_exes.append(test)
                if pid == py_pr.pid:
                    cpp_pr.kill()
                elif pid == cpp_pr.pid:
                    subprocess.check_call(args="sudo kill {}".format(py_pr.pid).split(), executable="sudo")
                else:
                    sys.stderr.write("Unknown PID: {}. Exiting.".format(pid))
                    # kill both
                    cpp_pr.kill()
                    subprocess.check_call(args="sudo kill {}".format(py_pr.pid).split(), executable="sudo")
                    exit(1)
                os.wait() # prepare for next test. No need to check return code: This process killed it.
            else:
                (_, retStatus) = os.wait()
                if failed_process(retStatus):
                    failed_exes.append(test)
    finally:
        # clean up pipes
        try:
            os.remove(cpp_wr_fifo_name)
        finally:
            try:
                os.remove(py_wr_fifo_name)
            finally:
                os.rmdir(tmp_dirname)

    if len(failed_exes):
        print(failed_exes, " FAILED")
        exit(1)
    else:
        print("ALL TESTS PASSED")

if __name__ == '__main__':
    main()
